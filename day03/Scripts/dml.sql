--PARENT
-- ID(PK), 이름, 나이, 주소, 핸드폰, 성별

CREATE SEQUENCE SEQ_PARENT;
CREATE TABLE TBL_PARENT(
	ID NUMBER CONSTRAINT PK_PARENT PRIMARY KEY,
	PARENT_NAME VARCHAR2(255) NOT NULL,
	PARENT_AGE NUMBER,
	PARENT_ADDRESS VARCHAR2(255) NOT NULL,
	PARENT_PHONE VARCHAR2(255) NOT NULL,
	PARENT_GENDER CHAR(10),
	CONSTRAINT GENDER_TYPE CHECK(PARENT_GENDER IN('M', 'W'))
);

-- SELECT 컬럼명1, 컬럼명2, ...
-- FROM 테이블1, 테이블2, ...

SELECT *
FROM TBL_PARENT;

-- INSERT INTO TLB_PARENT(컬럼명1, 컬럼명2 ....)
-- VALUES(값1, 값2, ...)

INSERT INTO TBL_PARENT(ID, PARENT_NAME, PARENT_AGE, PARENT_ADDRESS, PARENT_PHONE, PARENT_GENDER)
VALUES(SEQ_PARENT.NEXTVAL, '홍길동', 30, '경기도 과천시', '010-1234-5678', 'M');

INSERT INTO TBL_PARENT(ID, PARENT_NAME, PARENT_AGE, PARENT_ADDRESS, PARENT_PHONE, PARENT_GENDER)
VALUES(SEQ_PARENT.NEXTVAL, '장보고', 37, '경기도 군포시', '010-4456-1123', 'M');

INSERT INTO TBL_PARENT(ID, PARENT_NAME, PARENT_AGE, PARENT_ADDRESS, PARENT_PHONE, PARENT_GENDER)
VALUES(SEQ_PARENT.NEXTVAL, '김영희', 45, '경기도 안산시', '010-8813-6644', 'W');

INSERT INTO TBL_PARENT(ID, PARENT_NAME, PARENT_AGE, PARENT_ADDRESS, PARENT_PHONE, PARENT_GENDER)
VALUES(SEQ_PARENT.NEXTVAL, '김철수', 50, '서울시 관악구', '010-8354-4114', 'M');

INSERT INTO TBL_PARENT(ID, PARENT_NAME, PARENT_AGE, PARENT_ADDRESS, PARENT_PHONE, PARENT_GENDER)
VALUES(SEQ_PARENT.NEXTVAL, '이태희', 42, '경기도 고양시', '010-8364-4214', 'W');


-- WHERE 조건절
SELECT *
FROM TBL_PARENT;

SELECT ID, PARENT_NAME, PARENT_AGE, PARENT_ADDRESS, PARENT_PHONE, PARENT_GENDER 
FROM TBL_PARENT
WHERE PARENT_GENDER = 'M';

-- 40대 부모 데이터 중 여성
SELECT *
FROM TBL_PARENT
WHERE PARENT_AGE >= 40 AND PARENT_GENDER = 'W'; 

/*
 * 
 * LIKE: 포함된 문자열 값을 찾고, 문자의 개수도 제한을 줄 수 있다.
 * 
 * %: 모든 것
 * _: 글자 수
 * 
 * 예시
 '%A' : A로 끝나는 모든 값(NDFLSNJFA, 123NFJA, ...)
 'A%' : A로 시작하는 모든 값(AA, ANDKFS, AJD, ...)
 'A__' : A로 시작하며 3글자인 값(ABC, AAA, ADD, ...)
 '_A' : A로 끝나며 2글자인 값(FA, CA, DA, ...)
 '%A%' : A가 포함된 값(APPLE, BANANA, TASK, ...)
 * 
 * */

-- 경기도에 거주중인 부모를 조회
SELECT *
FROM TBL_PARENT
WHERE PARENT_ADDRESS LIKE '경기도%';

-- 이름이 '희'로 끝나는 부모의 데이터를 조회
SELECT *
FROM TBL_PARENT tp 
WHERE PARENT_NAME LIKE '%희';

-- 주소에 '과천'이 포함된 부모의 데이터를 조회
SELECT *
FROM TBL_PARENT tp 
WHERE PARENT_ADDRESS LIKE '%과천%';

-- 주소에 '과천'이 포함이 안된 부모의 데이터를 조회
SELECT *
FROM TBL_PARENT tp 
WHERE PARENT_ADDRESS NOT LIKE '%과천%';


===========================================================================
/*집계 함수
 * 
 * 평균 AVG()
 * 최대값 MAX()
 * 최소값 MIN()
 * 총 합 SUM()
 * 개수 COUNT()
 * 
 * */

CREATE SEQUENCE SEQ_FIELD_TRIP;
CREATE TABLE TBL_FIELD_TRIP(
	ID NUMBER CONSTRAINT PK_FIELD_TRIP PRIMARY KEY,
	FIELD_TRIP_TITLE VARCHAR2(255),
	FIELD_TRIP_CONTENT VARCHAR2(255),
	FIELD_TRIP_NUMBER NUMBER
);

INSERT INTO TBL_FIELD_TRIP
VALUES(SEQ_FIELD_TRIP.NEXTVAL, '어서와 매미농장', '매미 잡자 매미 잡자', 20);

INSERT INTO TBL_FIELD_TRIP
VALUES(SEQ_FIELD_TRIP.NEXTVAL, '아이스크림 빨리 먹기 대회', '아이스크림 누가 잘 먹나', 100);

INSERT INTO TBL_FIELD_TRIP
VALUES(SEQ_FIELD_TRIP.NEXTVAL, '고구마 심기', '고구마가 왕 커요', 10);

INSERT INTO TBL_FIELD_TRIP
VALUES(SEQ_FIELD_TRIP.NEXTVAL, '숭어 얼음 낚시', '숭어 잡자 추워도 참아!', 80);

INSERT INTO TBL_FIELD_TRIP
VALUES(SEQ_FIELD_TRIP.NEXTVAL, '커피 체험 공장', '커피 빈 객체화', 60);

INSERT INTO TBL_FIELD_TRIP
VALUES(SEQ_FIELD_TRIP.NEXTVAL, '치즈 제작하기', '여기 치즈 저기 치즈 이쪽 치즈 저쪽 치즈', 5);

INSERT INTO TBL_FIELD_TRIP
VALUES(SEQ_FIELD_TRIP.NEXTVAL, '승마 체험', '이리야!', 9);

SELECT *
FROM TBL_FIELD_TRIP;

/*집계 함수
 * 
 * 평균 AVG()
 * 최대값 MAX()
 * 최소값 MIN()
 * 총 합 SUM()
 * 개수 COUNT()
 * 
 * */

SELECT COUNT(*)
FROM TBL_FIELD_TRIP;

SELECT COUNT(ID) -- * 보다 성능 좋음
FROM TBL_FIELD_TRIP;

-- "": 컬럼명
-- '': 값
SELECT SUM(FIELD_TRIP_NUMBER) AS "총 수용인원"
FROM TBL_FIELD_TRIP;

-- 체험학습 평균 인원
-- ROUND(값, 자릿수) -> 반올림
SELECT ROUND(AVG(FIELD_TRIP_NUMBER), 1) AS "평균 인원"
FROM TBL_FIELD_TRIP;

-- 반올림
SELECT ROUND(AVG(FIELD_TRIP_NUMBER)) AS "평균 인원"
FROM TBL_FIELD_TRIP;

-- 내림
SELECT FLOOR(AVG(FIELD_TRIP_NUMBER)) AS "평균 인원"
FROM TBL_FIELD_TRIP;

-- 올림
SELECT CEIL(AVG(FIELD_TRIP_NUMBER)) AS "평균 인원"
FROM TBL_FIELD_TRIP;

-- 제목이 '체험'글자를 포함하는 체험 학습의 총 인원수 조회
SELECT SUM(FIELD_TRIP_NUMBER) AS "체험 글자를 포함한 체험의 총 인원"
FROM TBL_FIELD_TRIP 
WHERE FIELD_TRIP_TITLE LIKE '%체험%';

SELECT *
FROM TBL_FIELD_TRIP;


-- 체험학습 제목에 '고구마' 또는 '아이스크림' 들어간 체험 학습의 평균 인원 수
SELECT AVG(FIELD_TRIP_NUMBER) AS "고구마나 아이스크림이 들어간 체험 학습 평균 인원"
FROM TBL_FIELD_TRIP 
WHERE FIELD_TRIP_TITLE LIKE '%고구마%'
OR FIELD_TRIP_TITLE LIKE '%아이스크림%';

-- 체험학습에 제목이 '기'로 끝나는 체험 학습의 최소 인원수
SELECT MIN(FIELD_TRIP_NUMBER) AS "기로 끝나는 체험 학습의 최소 인원수"
FROM TBL_FIELD_TRIP 
WHERE FIELD_TRIP_TITLE LIKE '%기';

-- ==========================================

CREATE SEQUENCE SEQ_PRODUCT;
CREATE TABLE TBL_PRODUCT(
	ID NUMBER CONSTRAINT PK_PRODUCT PRIMARY KEY,
	PRODUCT_NAME VARCHAR2(255),
	PRODUCT_PRICE NUMBER,
	PRODUCT_STOCK NUMBER
);

SELECT * FROM TBL_PRODUCT;

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 1000, 20);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 2000, 40);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 4000, 30);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 1000, 60);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 3000, 80);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 2000, 10);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 5000, 20);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 2000, 15);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 2000, 65);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 5000, 40);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 3000, 17);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 1000, 25);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 3000, 25);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 4000, 20);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '배승원의 그램', 2000, 40);

SELECT * 
FROM TBL_PRODUCT;


-- 평균 인원보다 인원 수가 많은 체험 학습을 조회
-- 집계 함수를 사용할 수 있는 위치
-- 1. SELECT절

-- 2. HAVING절
-- SELECT *
-- FROM TBL_FIELD_TRIP
-- WHERE FIELD_TRIP_NUMBER > AVG(FIELD_TRIP_NUMBER);

-- GROUP BY
-- HAVING

-- SELECT 
-- FROM 
-- 생략가능
-- WHERE 
-- GROUP BY 
-- HAVING
-- ORDER BY

-- 1. GROUP BY로 지정한 컬럼만 조회할 수 있다.
-- 2. 그룹 합수를 조회할 수 있다.
SELECT PRODUCT_NAME, COUNT(PRODUCT_NAME)
FROM TBL_PRODUCT
GROUP BY PRODUCT_NAME;

SELECT 
	PRODUCT_NAME AS "상품명", 
	PRODUCT_PRICE AS "상품 가격", 
	COUNT(ID) AS "개수"
FROM TBL_PRODUCT 
GROUP BY PRODUCT_NAME, PRODUCT_PRICE
HAVING COUNT(ID) > 2;


-- HAVING은 GROUP BY의 조건절

SELECT 
	PRODUCT_NAME AS "상품명", 
	PRODUCT_PRICE AS "상품 가격", 
	COUNT(ID) AS "개수",
	AVG(PRODUCT_PRICE) AS "평균 가격"
FROM TBL_PRODUCT 
GROUP BY PRODUCT_NAME, PRODUCT_PRICE
HAVING AVG(PRODUCT_PRICE) > 2000;

SELECT * FROM TBL_PRODUCT;

-- 1) 가격대별 재고 수
SELECT 
	PRODUCT_PRICE || '원' AS "가격대",
	SUM(PRODUCT_STOCK) || '개'AS "재고 수"
FROM TBL_PRODUCT
GROUP BY PRODUCT_PRICE;

-- 2) 재고가 50개 이상인 상품의 개수
SELECT COUNT(ID) AS "재고가 50개 이상인 상품의 총 개수"
FROM TBL_PRODUCT
WHERE PRODUCT_STOCK >= 50;

-- 3) 재고가 30개 미만의 상품의 평균 가격
SELECT AVG(PRODUCT_PRICE) AS "재고가 30개 미만의 상품의 평균 가격"
FROM TBL_PRODUCT 
WHERE PRODUCT_STOCK < 30;

-- 4) 재고가 30개 미만 상품 가격대별의 총 가격 합계
SELECT 
	PRODUCT_PRICE AS "가격대",
	COUNT(PRODUCT_PRICE) AS "개수",
	SUM(PRODUCT_PRICE) AS "총 가격의 합"
FROM TBL_PRODUCT 
WHERE PRODUCT_STOCK < 30
GROUP BY PRODUCT_PRICE;

-- 5) 재고가 30개 미만 상품 가격대별의 개수가 2개 미만 상품의 총 가격 합계
SELECT 
	PRODUCT_PRICE AS "가격대",
	COUNT(PRODUCT_PRICE) AS "개수",
	SUM(PRODUCT_PRICE) AS "총 가격의 합"
FROM TBL_PRODUCT 
WHERE PRODUCT_STOCK < 30
GROUP BY PRODUCT_PRICE
HAVING COUNT(PRODUCT_PRICE) < 2;

-- WHERE 컬럼명 IN (값1, 값2, 값3, ...);

SELECT *
FROM TBL_PRODUCT
WHERE PRODUCT_STOCK IN ('20', '30', '40');

-- 가격이 1000, 5000, 3000인 상품만 조회
-- WHERE ~ IN
SELECT *
FROM TBL_PRODUCT
WHERE PRODUCT_PRICE IN ('1000', '3000', '5000');

-- 상품 재고가 15, 20, 25인 상품 중
-- 상품 재고별 개수와 평균 가격 구하기

SELECT 
	PRODUCT_NAME AS "상품명",
	SUM(PRODUCT_STOCK) || '개' AS "상품별 재고",
	ROUND(AVG(PRODUCT_PRICE)) || '원' AS "상품 평균 가격"
FROM TBL_PRODUCT
WHERE PRODUCT_STOCK IN ('15', '20', '25')
GROUP BY PRODUCT_STOCK, PRODUCT_NAME;

-- 모든 상품의 재고와 가격의 합
SELECT *
FROM TBL_PRODUCT;

SELECT 
	SUM(PRODUCT_PRICE) + SUM(PRODUCT_STOCK) AS "모든 상품의 재고와 가격의 합"
FROM TBL_PRODUCT;


-- 상품 가격대별 기대수익
SELECT
	PRODUCT_PRICE AS "가격대",
	SUM(PRODUCT_STOCK) AS "재고",
	PRODUCT_PRICE * SUM(PRODUCT_STOCK) AS "기대수익"
FROM TBL_PRODUCT
GROUP BY PRODUCT_PRICE;

-- 가격대별 10000원으로 살 수 있는 '배승원 노트북' 개수

SELECT 
	PRODUCT_NAME AS "노트북 이름",
	PRODUCT_PRICE || '원' AS "노트북 가격",
	FLOOR((10000 / PRODUCT_PRICE)) || '개' AS "살 수 있는 노트북 개수"
FROM TBL_PRODUCT
GROUP BY PRODUCT_PRICE, PRODUCT_NAME;






