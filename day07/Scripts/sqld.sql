SELECT DISTINCT TBP.PRODUCT_NAME
FROM TBL_ORDER TBO
JOIN TBL_PRODUCT TBP 
ON TBO.PRODUCT_ID = TBP.ID;

SELECT SYSDATE FROM DUAL;

-- 논리 연산자
--1. BETWEEN A AND : A부터 B까지
SELECT *
FROM(
	SELECT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID 
)
WHERE PRODUCT_PRICE BETWEEN 100000 AND 300000;

-- 같지 않다. !=, <>
SELECT *
FROM(
	SELECT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID 
)
WHERE PRODUCT_PRICE <> 119000;

-- IS NULL: 널인 데이터
-- IS NOT NULL: NULL이 아닌 데이터 조회 
SELECT *
FROM(
	SELECT TBO.*, TBP.PRODUCT_BRAND, TBP.PRODUCT_PRICE
	FROM TBL_ORDER TBO
	JOIN TBL_PRODUCT TBP 
	ON TBO.PRODUCT_ID = TBP.ID 
)
WHERE ORDER_END_DATE IS NOT NULL;

-- 문자열 함수
-- CONCAT(값, 값)
SELECT CONCAT('Hello', 'World') FROM DUAL;
SELECT 'Hello' || 'World' AS "인사" FROM  DUAL;

-- LENGTH(): 길이
SELECT LENGTH(CONCAT('Hello', 'World')) FROM DUAL;

-- SUBSTRING() -MySQL
-- SUBSTR(): 문자열 추출
SELECT SUBSTR('오늘 점심 뭐먹지?', 4, 2) FROM DUAL; -- 오라클은 인덱스 개념 없어서 0이 아닌 1부터 시작

-- 더미 테이블 생성
CREATE SEQUENCE SEQ_SQLD_PRODUCT;
CREATE TABLE TBL_SQLD_PRODUCT(
	ID NUMBER CONSTRAINT PK_SQLD_PRODUCT PRIMARY KEY,
	SQLD_PRODUCT_NAME VARCHAR2(255),
	SQLD_PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);
INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '지우개', 20000);
INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '키보드', 20000);
INSERT INTO TBL_SQLD_PRODUCT
VALUES(SEQ_SQLD_PRODUCT.NEXTVAL, '모니터', 20000);

CREATE SEQUENCE SEQ_SQLD_ORDER;
CREATE TABLE TBL_SQLD_ORDER(
	ID NUMBER CONSTRAINT PK_SQLD_ORDER PRIMARY KEY,
	SQLD_ORDER_NAME VARCHAR2(255),
	SQLD_PRODUCT_ID NUMBER,
	CONSTRAINT FK_SQLD_ORDER_SQLD_PRODUCT FOREIGN KEY(SQLD_PRODUCT_ID)
	REFERENCES TBL_SQLD_PRODUCT(ID)
);

INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 1);
INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '직접 수령', 2);
INSERT INTO TBL_SQLD_ORDER
VALUES(SEQ_SQLD_ORDER.NEXTVAL, '문 앞 배송', 2);

-- 중복 연산자
--1) DISTINCT: 조회 결과의 중복을 제거
--2) UNION: 중복을 제거하고, 두 컬럼 데이터 조회를 합친다
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
UNION
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

--3) UNION ALL: 중복을 제거하지 않고, 두 컬럼 데이터 조회를 합친다.
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
UNION ALL
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

--4) MINUS: 
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
MINUS
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

--5) INTERSECT: 교집합
SELECT SQLD_PRODUCT_NAME FROM TBL_SQLD_PRODUCT
INTERSECT
SELECT SQLD_ORDER_NAME FROM TBL_SQLD_ORDER;

-- 공집합 : 아무결과 안나오는 INTERSECT해서 

-- NULL 관련 연산자
--1) IS NULL: NULL이면 TRUE
--2) IS NOT NULL: NULL이 아니면 TRUE

-- ======================================================================
-- 함수
-- ====================================================================== 
-- 문자열 함수
-- UPPER(): 대문자로 변경
SELECT UPPER('hello') FROM DUAL;
-- LOWER(): 소문자로 변경
SELECT LOWER('DATING') FROM DUAL;

-- TRIM(): 공백제거
SELECT TRIM('      점 심 맛 있 게 먹 었 어?') FROM DUAL;

-- REPLACE(값, 찾을 문자, 바꿀 문자): 특정 문자를 치환
SELECT REPLACE('      점 심 맛 있 게 먹 었 어?', ' ', '') FROM DUAL;

-- INSTR(): 특정 문자열의 위치 반환
SELECT INSTR('강사님 질문해도 될까요?', '질문') FROM DUAL;

-- 날짜 함수
-- SYSDATE: 현재 날짜, 시, 분, 초
SELECT SYSDATE FROM DUAL;

-- CURRENT_DATE: 현재 날짜
SELECT CURRENT_DATE FROM DUAL;

-- 현재 날짜를 기준으로 월을 추가
SELECT ADD_MONTHS(SYSDATE, 3) FROM DUAL;  
SELECT ADD_MONTHS(SYSDATE, -3) FROM DUAL;  -- 같은 기능이므로 새로운 함수 이름을 안만듬 SUBTRACT_MONTHS

-- 달 차이
-- MONTHS_BETWEEN()

SELECT MONTHS_BETWEEN(SYSDATE, '2024-07-12') FROM DUAL;  
-- 일 차이
SELECT (SYSDATE - TO_DATE('2025-09-15 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) FROM DUAL;

-- 시 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 FROM DUAL;

-- 분 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 FROM DUAL;

-- 초 차이
SELECT (SYSDATE - TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS')) * 24 * 60 * 60 FROM DUAL;

-- NEXT_DAY()
-- 특정 날짜 이후의 지정된 요일을 반환
SELECT NEXT_DAY(SYSDATE, '월요일') FROM DUAL;

-- TRUNC(): 날짜의 시간을 제거하고 날짜만 반환
SELECT TRUNC(SYSDATE) FROM DUAL;

SELECT 
	TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS'),
	TO_CHAR(
		TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS'),
	'HH') AS "시간",
	TO_CHAR(
		TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS'),
	'MI') AS "분",
	TO_CHAR(
		TO_DATE('2025-09-18 11:15:00', 'YYYY-MM-DD HH24:MI:SS'),
	'YYYY') AS "년도"
FROM DUAL;
		

--TRUNCATE 
--SELECT * FROM TBL_INCOME;
--DROP FROM TBL_INCOME;


-- ABS(): 절댓값을 반환
SELECT ABS(-100) FROM DUAL;

-- CEIL(): 올림
SELECT CEIL(3.14) FROM DUAL;

-- FLOOR(): 내림
SELECT FLOOR(3.9) FROM DUAL;

-- MOD(): 나머지
SELECT MOD(5, 2) FROM DUAL;

-- ROUND(): 반올림
-- POWER(): 거듭제곱
SELECT POWER(2, 8) FROM DUAL;

-- 변환 함수
SELECT TO_NUMBER('12482.6') + 10 FROM DUAL;
SELECT TO_TIMESTAMP('2025-02-25 16:40:00', 'YYYY-MM-DD HH24:MI:SS') FROM DUAL; 
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;

--SELECT TO_DATE()
SELECT CAST(10 AS VARCHAR2(255)) FROM DUAL;
SELECT CAST('10.5' AS NUMBER) FROM DUAL;
SELECT CAST('2025-02-27' AS DATE) FROM DUAL;

-- *NULL 함수
-- NVL(값1, 값2): 첫 번째 값이 NULL이면 두 번째 값을 반환함
SELECT NVL(NULL, '대체 값') FROM DUAL;

-- 삼항
-- NVL2(값1, 값2, 값3): NULL이면 값3, NULL이 아니면 값2
SELECT NVL2(NULL, 'TRUE', 'FALSE') FROM DUAL;
SELECT NVL2(10, 'TRUE', 'FALSE') FROM DUAL;

-- COALESCE(값1, 값2, 값3, 값4, ...): 값 중 NULL이 아닌 첫 번째 값을 반환
SELECT COALESCE(NULL, 0, NULL, 15) FROM DUAL;

-- NULLIF(): 두 값이 같으면 NULL, 아니라면 첫 번째 값
SELECT NULLIF(10, NULL) FROM DUAL;
SELECT NULLIF(10, 10) FROM DUAL;
SELECT NULLIF(10, 15) FROM DUAL;

-- 조건식
-- IS NULL
-- IS NOT NULL

-- CASE문
SELECT 
	CASE BUYER_GENDER 
		WHEN '남' THEN '남성 고객'
		WHEN '여' THEN '여성 고백'
		ELSE '중성 고객'
	END AS "고객 성별"
FROM TBL_BUYER;

-- START WITH
-- CONNECT BY PRIOR 부모와 자식 관계

CREATE SEQUENCE SEQ_PRODUCT;
CREATE TABLE TBL_PRODUCT(
	ID NUMBER CONSTRAINT PK_PRODUCT PRIMARY KEY,
	PRODUCT_NAME VARCHAR2(255),
	PRODUCT_PRICE NUMBER
);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 10000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 30000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '마우스', 35000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 300000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '컴퓨터', 220000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 40000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '모니터', 30000);

INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 55000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 12000);
INSERT INTO TBL_PRODUCT
VALUES(SEQ_PRODUCT.NEXTVAL, '스피커', 30000);

SELECT 
	PRODUCT_NAME,
	PRODUCT_PRICE,
	RANK() OVER(PARTITION BY PRODUCT_NAME ORDER BY PRODUCT_PRICE DESC) AS "RANK",
	DENSE_RANK() OVER(PARTITION BY PRODUCT_NAME ORDER BY PRODUCT_PRICE DESC) AS "DENSE_RANK",
	ROW_NUMBER() OVER(ORDER BY PRODUCT_PRICE DESC) AS "ROWS_NUMBER",
	SUM(PRODUCT_PRICE) OVER(PARTITION BY PRODUCT_NAME) AS "SUM"
FROM TBL_PRODUCT;

SELECT 
	PRODUCT_PRICE,
	LEAD(PRODUCT_PRICE, 2) OVER(ORDER BY PRODUCT_PRICE) AS "LEAD",
	LAG(PRODUCT_PRICE, 2) OVER(ORDER BY PRODUCT_PRICE) AS "LAG",
	FIRST_VALUE(PRODUCT_PRICE) OVER(ORDER BY PRODUCT_PRICE) AS "FIRST_VALUE",
	LAST_VALUE(PRODUCT_PRICE) OVER(
		ORDER BY PRODUCT_PRICE
		ROWS BETWEEN 1 PRECEDING AND 5 FOLLOWING
	) AS "LAST_VALUE",
	NTH_VALUE(PRODUCT_PRICE, 2) OVER(ORDER BY PRODUCT_PRICE) AS "NTH_VALUE",
	CUME_DIST() OVER(ORDER BY PRODUCT_PRICE) AS "NTH_VALUE",
	PERCENT_RANK() OVER(ORDER BY PRODUCT_PRICE) AS "PERCENT_RANK"
FROM TBL_PRODUCT;

-- 집계쿼리 
SELECT 
	PRODUCT_NAME, PRODUCT_PRICE,
	SUM(PRODUCT_PRICE)
FROM TBL_PRODUCT
GROUP BY CUBE(PRODUCT_NAME, PRODUCT_PRICE);


SELECT 
	PRODUCT_NAME, PRODUCT_PRICE,
	SUM(PRODUCT_PRICE)
FROM TBL_PRODUCT
GROUP BY GROUPING SETS(
	(PRODUCT_NAME, PRODUCT_PRICE),
	PRODUCT_PRICE,
	()
);











	